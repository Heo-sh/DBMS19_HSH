DECLARE
	SCORE NUMBER := 80; -- := -> 우측에 있는 값을 좌측에 대입한다라는 의미
	GRADE VARCHAR2(5); --어떤 학점인지 정확히 알 수 없기에 값을 미리 넣을 수 없다.
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;											--CHR(n): VARCHAR2 값으로 n에 해당하는 아스키코드를 TEXT로 변환한 값
	DBMS_OUTPUT.PUT_LINE('당신의 점수: '||SCORE||'점'||CHR(10)||'학점: '||GRADE);
                                                    --CHR(10): LF -> LINE FEED라 하며 개행문자라 한다. 여기서의 역할은 줄바꿈이다.
END;
-- -> 위의 쿼리문을 프로시저로 만들어볼 것이다.
--학점을 부여하는 프로시저
--제어문의 속성중 조건
CREATE OR REPLACE PROCEDURE GET_GRADE (
	SCORE NUMBER -- -> 외부에서 받을 변수
)
IS
	GRADE VARCHAR2(5); --학점은 외부에서 전달받는 게 아니라 IS 영역에 저장, 내부에서 변화할 변수
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;
	DBMS_OUTPUT.PUT_LINE('당신의 점수: '||SCORE||'점'||CHR(10)||'학점: '||GRADE);
END;

CALL GET_GRADE(6);
CALL GET_GRADE(100);

--1 부터 100까지의 총합
--제어문의 속성 중 반복
DECLARE
	NUM NUMBER := 1; --시작값
	TOTAL NUMBER := 0; --더하기 연산을 100번 마친 후 나온 값을 담을 그릇
BEGIN
	WHILE NUM <= 100
	LOOP
		TOTAL := TOTAL + NUM;
		NUM := NUM + 1;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('1~100까지의 합산 결과: '||TOTAL);
END;

--1~N까지의 총합
CREATE OR REPLACE PROCEDURE TOTAL_PROC (
	P_NUM NUMBER
)
IS
	TOTAL NUMBER := 0; --총합을 담을 값
	NUM NUMBER := 1; --시작값
BEGIN
	WHILE NUM <= P_NUM
	LOOP
		TOTAL := TOTAL + NUM;
		NUM := NUM + 1;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('1~'||P_NUM||'까지의 합산 결과: '||TOTAL);	
END;

CALL TOTAL_PROC(5000);

--UPDATE와 INSERT를 동시에 해주는 프로시저
CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC (
	P_JOB_ID IN JOBS.JOB_ID%TYPE, 
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
	CNT NUMBER := 0; --개수를 세주는 변수
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT --JOBS로부터 CNT를 셋다면 변수에 저장을 하라
	FROM JOBS WHERE JOB_ID = P_JOB_ID;
	IF CNT = 0 THEN 
		INSERT INTO JOBS(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
		VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
		DBMS_OUTPUT.PUT_LINE('INSERT ALL DONE ABOUT'||' '||P_JOB_ID);
	ELSE
		UPDATE JOBS
		SET
		JOB_TITLE = P_JOB_TITLE,
		MIN_SALARY = P_MIN_SALARY,
		MAX_SALARY = P_MAX_SALARY
		WHERE JOB_ID = P_JOB_ID;
		DBMS_OUTPUT.PUT_LINE('UPDATE ALL DONE ABOUT'||' '||P_JOB_ID);
	END IF;
END;

SELECT * FROM JOBS;

CALL MY_NEW_JOB_PROC('IT', 'Developer', 5000, 14000);

--제거(DELETE)프로시저 만들기 DEL_JOB_PROC
--DB에 데이터가 있으면 삭제, 없으면 'NO EXISIT IT' 출력
CREATE OR REPLACE PROCEDURE DEL_JOB_PROC (
	P_JOB_ID IN JOBS.JOB_ID%TYPE 
)
IS
	CNT NUMBER := 0;
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT
	FROM JOBS WHERE JOB_ID = P_JOB_ID;
	IF CNT > 0 THEN --== IF CNT != 0 THEN: 0이 아니라는 말은 DB에 삭제할 JOB_ID 데이터가 존재한다라는 의미
	DELETE FROM JOBS WHERE JOB_ID = P_JOB_ID;
	DBMS_OUTPUT.PUT_LINE('DELETE ALL DONE ABOUT'||' '||P_JOB_ID);
	ELSE
	DBMS_OUTPUT.PUT_LINE('NO EXISIT IT'||' '||P_JOB_ID);
	END IF;
END;

CALL DEL_JOB_PROC('IT');

SELECT * FROM JOBS;
----------------------------------------------------------------
--SEQUENCE
CREATE SEQUENCE USER_COUNT;

CREATE TABLE USER2 (
	ID NUMBER,
	NAME VARCHAR2(200)
);

INSERT INTO USER2 VALUES(USER_COUNT.NEXTVAL, '홍길동');
INSERT INTO USER2 VALUES(USER_COUNT.NEXTVAL, '김길동');
INSERT INTO USER2 VALUES(USER_COUNT.NEXTVAL, '박길동');

SELECT * FROM USER2;
----------------------------------------------------
--OPTIMIZER
SELECT * FROM PLAYER ORDER BY PLAYER_ID DESC;

CREATE SEQUENCE MEMBER_SEQ;
CREATE TABLE TBL_MEMBER (
	NUM NUMBER PRIMARY KEY,
	ID VARCHAR2(200),
	PW VARCHAR2(200),
	NAME VARCHAR2(200),
	AGE NUMBER
);
