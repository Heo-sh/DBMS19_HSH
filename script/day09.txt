--VIEW
--PLAYER 테이블에서 선수의 현재 나이를 출력하라
SELECT * FROM PLAYER;

SELECT ROUND((SYSDATE-BIRTH_DATE)/365) "AGE", PLAYER.* FROM PLAYER;

CREATE VIEW PLAYER_AGE AS (
	SELECT ROUND((SYSDATE-BIRTH_DATE)/365) "AGE", PLAYER.* FROM PLAYER
);

SELECT * FROM PLAYER_AGE;

DROP VIEW PLAYER_AGE; --VIEW를 DELETE

--30살이 넘는 선수들 조회
SELECT AGE, PLAYER_ID, PLAYER_NAME
FROM PLAYER_AGE
WHERE AGE > 30;

SELECT * FROM EMPLOYEES;
CREATE VIEW EMPLOYEES_MANAGER AS (
	SELECT E1.LAST_NAME||' '||E1.FIRST_NAME AS ENAME,
		   E2.LAST_NAME||' '||E2.FIRST_NAME AS MNAME
	FROM EMPLOYEES E1
	JOIN EMPLOYEES E2
	ON E1.MANAGER_ID = E2.EMPLOYEE_ID
);

SELECT * FROM EMPLOYEES_MANAGER;

--KING STEVEN의 사원 목록 조회
SELECT * FROM EMPLOYEES_MANAGER
WHERE MNAME = 'King Steven';

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, (SALARY * COMMISSION_PCT)
FROM EMPLOYEES;

CREATE VIEW DATA_PLUS AS (
	SELECT EMPLOYEES.*, (SALARY * COMMISSION_PCT) AS COMM
	FROM EMPLOYEES
);

SELECT * FROM DATA_PLUS;

DROP VIEW DATA_PLUS;

--RANK(): 순위를 매겨주는 함수
SELECT SALARY,RANK() OVER(ORDER BY SALARY DESC) "RANK" 
FROM EMPLOYEES;
SELECT SALARY,RANK() OVER(ORDER BY SALARY DESC) "RANK" 
FROM EMPLOYEES
ORDER BY SALARY DESC;

CREATE VIEW DATA_PLUS AS (
	SELECT FIRST_NAME||' '||LAST_NAME "NAME", SALARY, RANK() OVER(ORDER BY SALARY DESC) "RANK"
	FROM EMPLOYEES
);

SELECT * FROM DATA_PLUS;

--PLAYER 테이블에 TEAM_NAME 컬럼을 추가한 VIEW 만들기 (JOIN 사용)
--TEAM_NAME -> TEAM 테이블에 있음
--VIEW NAME = PLAYER_TEAM_NAME
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT P.*, T.TEAM_NAME
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID;

CREATE VIEW PLAYER_TEAM_NAME AS (
	SELECT T.TEAM_NAME, P.*
	FROM PLAYER P JOIN TEAM T
	ON P.TEAM_ID = T.TEAM_ID
);

SELECT * FROM PLAYER_TEAM_NAME;

--TEAM_NAME이 울산현대인 선수 모두 조회
SELECT TEAM_NAME, PLAYER_NAME FROM PLAYER_TEAM_NAME
WHERE TEAM_NAME = '울산현대';

--HOMETEAM_ID, STADIUM_NAME, TEAM_NAME을 조회하되,
--HOMETEAM이 없는 경기장까지 조회가 되도록 VIEW로 만들기
SELECT * FROM TEAM;
SELECT * FROM STADIUM;

SELECT S.HOMETEAM_ID, S.STADIUM_NAME, T.TEAM_NAME
FROM TEAM T RIGHT OUTER JOIN STADIUM S
ON T.TEAM_ID = S.HOMETEAM_ID;

CREATE VIEW STADIUM_INFO AS (
	SELECT S.HOMETEAM_ID, S.STADIUM_NAME, T.TEAM_NAME
	FROM TEAM T RIGHT OUTER JOIN STADIUM S
	ON T.TEAM_ID = S.HOMETEAM_ID
);

SELECT * FROM STADIUM_INFO;

--STADIUM_INFO에서 TEAM_NAME이 NULL인 경기장 조회
SELECT * FROM STADIUM_INFO
WHERE TEAM_NAME IS NULL;

--1) EMPLOYEES 테이블에서 사원들의 FIRST_NAME을 모두 조회
--2) 사원들 중에서 매니저들은 JOB_ID 조회
--SUB QUERY문
CREATE VIEW MANAGER_INFO AS (
	SELECT E2.JOB_ID, E1.FIRST_NAME
	FROM EMPLOYEES E1 LEFT OUTER JOIN (
		SELECT JOB_ID, MANAGER_ID M 
		FROM EMPLOYEES) E2
	ON E1.EMPLOYEE_ID = E2.M
);

--3)VIEW로 만들고 매니저가 아니면서 FIRST_NAME이 A로 시작하는 사원 검색
SELECT * FROM MANAGER_INFO
WHERE JOB_ID IS NULL AND FIRST_NAME LIKE 'A%';

------------------------------------------------------------------------------------
--PROCEDURE

BEGIN
	DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END; --SHOW SERVER OUTPUT CONSOLE에서 확인 가능

CREATE OR REPLACE PROCEDURE F (
	X IN NUMBER 
)
IS
BEGIN
	DBMS_OUTPUT.PUT_LINE(2*X + 1);
END;

CALL F(3);

--예제
--JOBS 테이블에 INSERT해주는 프로시저 만들기
--우리가 매번 INSERT 하는 명령을 써주기 귀찮기에 프로시저로 만들어
--CALL하면 한번에 추가되도록 만들어보기
SELECT * FROM JOBS;
INSERT INTO JOBS(?, ?, ?, ?);

CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC (
	P_JOB_ID IN JOBS.JOB_ID%TYPE, --JOB_ID의 TYPE을 그대로 가져가겠다라는 의미
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
BEGIN
	INSERT INTO JOBS(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
	VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
	DBMS_OUTPUT.PUT_LINE('ALL DONE ABOUT'||' '||P_JOB_ID);
END;

CALL MY_NEW_JOB_PROC('IT', 'Developer', 14000, 20000);

SELECT * FROM JOBS;
-----------------------------------------------------------------
--PL/SQL문(IF문)
DECLARE
	SCORE NUMBER := 80; -- := -> 우측에 있는 값을 좌측에 대입한다라는 의미
	GRADE VARCHAR2(5); --어떤 학점인지 정확히 알 수 없기에 값을 미리 넣을 수 없다.
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;											--CHR(n): VARCHAR2 값으로 n에 해당하는 아스키코드를 TEXT로 변환한 값
	DBMS_OUTPUT.PUT_LINE('당신의 점수: '||SCORE||'점'||CHR(10)||'학점: '||GRADE);
                                                    --CHR(10): LF -> LINE FEED라 하며 개행문자라 한다. 여기서의 역할은 줄바꿈이다.
END;
