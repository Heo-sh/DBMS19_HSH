SELECT AVG(HEIGHT), MAX(HEIGHT), MIN(HEIGHT), SUM(HEIGHT), COUNT(HEIGHT) FROM PLAYER;

SELECT * FROM PLAYER;

--PLAYER 테이블에서 HEIGHT 개수 검색(NULL 포함해서 COUNT하기)
SELECT COUNT(NVL(HEIGHT,0)) FROM PLAYER;

--일반적으로 집계함수와 일반컬럼은 함께 쓸 수 없다.
SELECT COUNT(*)FROM EMPLOYEES;
SELECT COUNT(*), FRIST_NAME FROM EMPLOYEES; --오류가 뜬다.

--사원테이블에서 직종이 SA_REP인 사원들의 평균급여, 급여최고액, 급여최저액, 급여의 총 합을 출력하라.
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY), SUM(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'SA_REP';

--EMPLOYEES 테이블의 부서 개수 출력
SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES; --중복까지 같이 개수를 세어버린다. 106

SELECT * FROM EMPLOYEES;

--DISTINCT: 중복된 값은 세지 않는다.
SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM EMPLOYEES; --11

--부서번호가 80번인 부서의 사원들의 급여의 평균을 소수점 한자리까지 반올림하여 출력
SELECT ROUND(AVG(SALARY), 1)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

--EMPLOYEES 테이블에서 MANAGER의 개수를 출력
SELECT COUNT(DISTINCT MANAGER_ID)
FROM EMPLOYEES;

--EMPLOYEES 테이블에서 50번 부서에 속하는 사원들의 급여의 최댓값, 최소값 출력
SELECT MAX(SALARY) "최댓값", MIN(SALARY) "최소값"
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50;

--그룹화
--SELECT절에 일반컬럼과 집계함수를 같이 사용할 수 있다.
--각 부서별 급여의 평균과 총 합
SELECT DEPARTMENT_ID "부서 ID", COUNT(*) "인원 수", AVG(SALARY), SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--부서가 같아도 직종이 다른 경우가 있기에 좀 더 세부적인 결과물을 가져올 수 있는 게 GROUP BY이다.

--각 직종별 인원 수 출력
SELECT JOB_ID "직종", COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID;

--각 직종별 급여의 합을 출력
SELECT JOB_ID, SUM(SALARY) "급여 총합"
FROM EMPLOYEES
GROUP BY JOB_ID;

--부서별로 가장 높은 급여를 조회
SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--각 부서의 급여의 최대값, 최소값, 인원수를 출력하되, 급여의 최대값이 8000 이상인 결과만 출력
SELECT DEPARTMENT_ID, MAX(SALARY), MIN(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) >= 8000;

--각 부서의 인원 수가 20명 이상인 부서의 정보를 부서번호, 급여의 합, 급여의 평균, 인원 순으로 출력
--급여의 평균은 소수점 2번째 자리까지만 출력
SELECT DEPARTMENT_ID "부서 번호", SUM(SALARY) "급여 총 합", ROUND(AVG(SALARY), 2) "급여 평균", COUNT(*) "인원 수"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(DEPARTMENT_ID) >= 20; -- == HAVING COUNT(*) >= 20

--부서별, 직종별로 그룹화 하여 결과를 부서번호, 직종, 인원 수 순으로 출력
--단, 직종이 'MAN'으로 끝나는 경우에만 출력
SELECT DEPARTMENT_ID "부서 번호", JOB_ID "직종", COUNT(*) "인원 수"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
HAVING JOB_ID LIKE '%MAN';

SELECT DEPARTMENT_ID, JOB_ID, COUNT(*)
FROM EMPLOYEES
WHERE JOB_ID LIKE '%MAN' --일반 컬럼이기에 WHERE절이 낫다.
GROUP BY DEPARTMENT_ID, JOB_ID; 

--각 부서별 평균 급여를 소수점 한자리까지 버림으로 출력하되, 평균 급여가 10000미만인 그룹만 조회해야 하며,
--부서번호가 50번 이하인 부서만 조회
SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY), 1)
FROM EMPLOYEES
WHERE DEPARTMENT_ID <= 50
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) < 10000;

SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY), 1)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) < 10000 AND DEPARTMENT_ID <= 50;

--각 부서별 부서번호, 급여의 합, 평균, 인원 수 순으로 출력하되,
--급여의 합이 30000 이상인 경우에만 출력해야 하며,
--급여의 평균은 소수점 2번째 자리까지 반올림하여 출력
SELECT DEPARTMENT_ID "부서 번호", SUM(SALARY) "급여 총 합", ROUND(AVG(SALARY),2) "급여 평균", COUNT(*) "인원 수"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) >= 30000;

--PLAYER 테이블에서 각 포지션 별로 몸무게가 80 이상이고, 선수들의 평균 키가 180 이상인  포지션, 평균 키 출력
SELECT * FROM PLAYER;

SELECT "POSITION", AVG(HEIGHT)
FROM PLAYER
WHERE WEIGHT >= 80
GROUP BY "POSITION"
HAVING AVG(HEIGHT) >= 180;

SELECT "POSITION", AVG(HEIGHT)
FROM PLAYER
GROUP BY "POSITION"
HAVING AVG(HEIGHT) >= 180 AND "POSITION" = 'GK'; 
--HAVING AVG(HEIGHT) >= 180 AND WEIGHT >= 80; --왜 이건 안될까? POSITION 칼럼이 문자열이기 때문일까?
--아니면 GROUP BY 에 있는 컬럼과 AND에 있는 컬럼이 달라서 일까? > 이게 정답인 듯 하다.
--HAVING에서 AND나 OR을 쓰고 싶은 경우에는 GROUP BY에 쓰여진 컬럼으로 기준을 정할 때나 사용 가능하다.

--ORDER BY
SELECT * FROM PLAYER ORDER BY HEIGHT; --기본은 오름차순
SELECT * FROM PLAYER ORDER BY HEIGHT DESC; --내림차순
SELECT * FROM PLAYER ORDER BY 12 DESC; --12번째 컬럼을 기준으로 내림차순으로 조회하라
SELECT * FROM PLAYER ORDER BY HEIGHT DESC, WEIGHT DESC; --동시적으로 조회 가능, 먼저 적힌 것을 순으로 정렬한다.

--부서별, 직종별로 그룹을 나눠서 인원 수를 출력하되, 부서번호 낮은 순으로 정렬
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;

--CASE문
--EMP 테이블에서 SAL 3000 이상이면 HIGH, 1000 이상이면 MID, 다 아니라면 LOW 
SELECT * FROM EMP;

SELECT ENAME "사원명", SAL "급여",
CASE
	WHEN SAL >= 3000 THEN 'HIGH'
	WHEN SAL >= 1000 THEN 'MID'
	ELSE 'LOW'
END "등급"
FROM EMP;

--직종이 'IT_PROG'인 사람들의 평균급여를 출력
SELECT ROUND(AVG(CASE JOB_ID WHEN 'IT_PROG' THEN SALARY END), 2) "평균급여"
FROM EMPLOYEES;

--CASE와 WHEN 사이에 컬럼명을 넣고 WHEN과 THEN 사이에 비교하고자 하는 값을 넣어서 비교할 수 있다.

--STADIUM 테이블에서 SEAT_COUNT 0 이상 30000 이하이면 'S'
--30001 이상 50000 이하이면 'M' 다 아니라면 'L'로 출력
--CASE문의 중첩
SELECT * FROM STADIUM;
SELECT STADIUM_NAME "경기장", SEAT_COUNT "좌석 수",
CASE
	WHEN SEAT_COUNT BETWEEN 0 AND 30000 THEN 'S'
	ELSE
		(
		CASE 
			WHEN SEAT_COUNT BETWEEN 30001 AND 50000 THEN 'M'
			ELSE 'L'
		END
		)
END "등급"
FROM STADIUM;

--PLAYER 테이블에서 WEIGHT 50 이상 70 이하이면 'L',
--71 이상 80 이하이면 'M' NULL이면 '미등록' 다 아니라면 'H'
SELECT * FROM PLAYER;
SELECT PLAYER_NAME, WEIGHT,
CASE
	WHEN WEIGHT BETWEEN 50 AND 70 THEN 'L'
	WHEN WEIGHT BETWEEN 71 AND 80 THEN 'M'
	WHEN WEIGHT IS NULL THEN '미등록'
	ELSE 'H'
END "체급"
FROM PLAYER;

SELECT PLAYER_NAME,
CASE
	WHEN WEIGHT BETWEEN 50 AND 70 THEN 'L'
	ELSE
		(
		CASE
			WHEN WEIGHT BETWEEN 71 AND 80 THEN 'M'
			ELSE
				(
				CASE
					WHEN WEIGHT IS NULL THEN '미등록'
					ELSE 'H'
				END
				)
		END
		)
END
FROM PLAYER;

--SUB QUERY
--FROM절에서 쓰이는 경우
--PLAYER 테이블에서 TEAM_ID가 'K01'인 선수 중 포지션이 'GK'인 선수 출력
SELECT * FROM (SELECT * FROM PLAYER WHERE TEAM_ID = 'K01') WHERE "POSITION" = 'GK';

--PLAYER 테이블에서 평균 키보다 작은 선수 검색
--1)평균 키 조회
SELECT AVG(HEIGHT) FROM PLAYER;
--2)PLAYER 테이블에서 179보다 작은 선수 검색
SELECT * FROM PLAYER WHERE HEIGHT < 179;
--SUB QUERY
SELECT * FROM PLAYER WHERE HEIGHT < (SELECT AVG(HEIGHT) FROM PLAYER);

