--SUB QUERY를 사용하는 이유
--데이터베이스에 한번만 접근을 하는 걸로는 답을 구하기 어렵다.
--EMPLOYEES 테이블에서 이름이 'Michael'이고, 직종이 'MK_MAN'인 사원의 급여보다
--많이 받는 사원들의 정보를 사번, 이름, 직종 급여 순으로 출력

--1) 이름이 Michael이고, 직종이 'MK_MAN'인 사원의 급여 구하기
SELECT SALARY 
FROM EMPLOYEES 
WHERE FIRST_NAME = 'Michael' AND JOB_ID = 'MK_MAN'; --13000

--2) 13000보다 급여가 높은 사원들의 정보 구하기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID 
FROM EMPLOYEES
WHERE SALARY > 13000;

--3) 위의 두 쿼리문을 SUB QUERY문을 통해 하나로 합친다.
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY 
				FROM EMPLOYEES 
				WHERE FIRST_NAME = 'Michael' AND JOB_ID = 'MK_MAN'); --13000
				
--SELECT문을 몇 개 작성해야 하는지 알면 SUB QUERY를 작성하는 건 어렵지 않다.

--사번이 150번인 사원의 급여와 같은 급여를 받는 사원들의 정보를 사번, 이름, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY = (SELECT SALARY
				FROM EMPLOYEES
				WHERE EMPLOYEE_ID = 150);

--급여가 회사의 평균급여 이상인 사람들의 이름과 급여를 출력
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= (SELECT AVG(SALARY)
				FROM EMPLOYEES);

--사번이 111번인 사원의 직종과 같고, 사번이 159번인 사원의 급여보다 많이 받는 사원들의 정보를
--사번, 이름, 직종, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID
				FROM EMPLOYEES
				WHERE EMPLOYEE_ID = 111)
				AND SALARY > (SELECT SALARY
		  					  FROM EMPLOYEES
						      WHERE EMPLOYEE_ID = 159);

--직종별 평균급여를 출력하되, 평균급여가 Bruce사원보다 큰(초과) 경우를 조회
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) > (SELECT SALARY
					  FROM EMPLOYEES
					  WHERE FIRST_NAME = 'Bruce');

--사원 테이블에서 성에 'Bat'이라는 단어를 포함하고 있는 사원과 같은 부서에서 근무하는 사원의
--부서번호, 이름을 출력
SELECT DEPARTMENT_ID, FIRST_NAME, LAST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
					   FROM EMPLOYEES
					   WHERE LAST_NAME LIKE '%Bat%');

--PLAYER 테이블에서 전체 평균키와 포지션별 평균키 구하기
SELECT "POSITION", AVG(HEIGHT), (SELECT AVG(HEIGHT) FROM PLAYER)
FROM PLAYER
WHERE "POSITION" IS NOT NULL
GROUP BY "POSITION";
--CASE문으로 변경
SELECT
	ROUND(AVG(CASE "POSITION" WHEN 'GK' THEN HEIGHT END),2) AS GK,
	ROUND(AVG(CASE "POSITION" WHEN 'DF' THEN HEIGHT END),2) AS DF,
	ROUND(AVG(CASE "POSITION" WHEN 'FW' THEN HEIGHT END),2) AS FW,
	ROUND(AVG(CASE "POSITION" WHEN 'MF' THEN HEIGHT END),2) AS MF,
	ROUND(AVG(HEIGHT), 2) AS "전체평균"
FROM PLAYER;
-------------------------------------------------------------------------
--JOIN
--INNER JOIN
--EMP 테이블의 부서번호(DEPTNO)로 DEPT 테이블의 지역(LOC) 조회하기
SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT * FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; --JOIN의 앞 뒤의 테이블명을 바꾸면 위치가 바뀌어 합쳐져서 조회된다.
--INNER은 생략가능

--DEPT 테이블에서 부서번호에 해당하는 위치를 가져올 수 있다.
SELECT EMP.DEPTNO, EMP.ENAME, EMP.JOB, DEPT.LOC
FROM EMP JOIN DEPT 
ON EMP.DEPTNO = DEPT.DEPTNO; --하나의 테이블인 냥 조회 가능

--PLAYER 테이블에서 송종국선수가 속한 팀의 전화번호 조회
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT P.TEAM_ID, P.PLAYER_NAME, T.TEL
FROM PLAYER P JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID
WHERE P.PLAYER_NAME = '송종국';

SELECT P.TEAM_ID, P.PLAYER_NAME, T.TEL
FROM PLAYER P JOIN TEAM T 
ON P.TEAM_ID = T.TEAM_ID AND P.PLAYER_NAME = '송종국';

--JOBS 테이블에서 JOB_ID로 EMPLOYEES의 JOB_TITLE, EMAIL, LAST_NAME, FIRST_NAME 조회
SELECT * FROM JOBS;

SELECT J.JOB_ID, J.JOB_TITLE, E.EMAIL, E.LAST_NAME|| ' ' || E.FIRST_NAME "이름"
FROM JOBS J JOIN EMPLOYEES E 
ON J.JOB_ID = E.JOB_ID;

--급여로 등급 나누기
SELECT * FROM SALGRADE;
SELECT * FROM EMP;

SELECT E.EMPNO, E.ENAME, S.GRADE, E.SAL
FROM SALGRADE S JOIN EMP E
ON E.SAL BETWEEN S.LOSAL AND S.HISAL; --등호가 없기에 비등가 조인이다.

--EMPLOYEES 테이블에서 HIREDATE가 2003~2005년까지인 사원의 정보를 입사일, 이름, 부서이름으로 조회
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;

SELECT E.HIRE_DATE, E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.HIRE_DATE BETWEEN TO_DATE('2003-01','YYYY-MM') AND TO_DATE('2006-01', 'YYYY-MM');

SELECT * FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;
SELECT * FROM EMP INNER JOIN DEPT USING(DEPTNO);
--USING(): 중복되는 컬럼이 생길 시 맨 앞으로 출력하며 중복 컬럼을 한 개만 출력한다.

--NATURAL JOIN
SELECT * FROM EMP NATURAL JOIN DEPT; --USING을 사용한 효과와 같은 효과를 얻는다.

--외부 조인(OUTER JOIN)
--LEFT OUTER JOIN
SELECT * FROM STADIUM;
SELECT * FROM TEAM;

SELECT * FROM STADIUM JOIN TEAM
ON HOMETEAM_ID = TEAM_ID; --NULL값은 생략조회

SELECT * FROM STADIUM LEFT OUTER JOIN TEAM
ON HOMETEAM_ID = TEAM_ID;

--RIGHT OUTER JOIN
SELECT * FROM STADIUM RIGHT OUTER JOIN TEAM
ON HOMETEAM_ID = TEAM_ID;

--FULL OUTER JOIN
--좌측 테이블과 우측 테이블의 모든 데이터를 읽어서 중복되는 데이터는 삭제한 JOIN 결과를 출력한다.
SELECT * FROM STADIUM FULL OUTER JOIN TEAM
ON HOMETEAM_ID = TEAM_ID;

--SELF JOIN
SELECT * FROM EMP;

--EMP 테이블에서 MGR을 통해 매니저의 이름을 알고 싶을 때
SELECT * FROM EMP E1 JOIN EMP E2
ON E1.MGR = E2.EMPNO;

SELECT E1.ENAME 사원, E2.ENAME 매니저
FROM EMP E1 JOIN EMP E2
ON E1.MGR = E2.EMPNO;

--DEPT 테이블의 LOC별 평균 SAL을 소수점 첫째 자리에서 반올림하고, SAL의 총합을 구하세요.
SELECT * FROM DEPT;
SELECT * FROM EMP;

SELECT D.LOC, ROUND(AVG(SAL)) "평균 급여", SUM(SAL) "총 급여"
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
GROUP BY D.LOC;

--DEPARTMENTS 테이블과 LOCATAIONS 테이블로부터 부서이름과 CITY를 조회하라.
SELECT * FROM DEPARTMENTS;
SELECT * FROM LOCATIONS;

SELECT D.DEPARTMENT_NAME, L.CITY
FROM DEPARTMENTS D JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

--지역(LOCATIONS), 나라(COUNTRIES)로부터 도시명과 국가명을 조회
SELECT * FROM LOCATIONS;
SELECT * FROM COUNTRIES;

SELECT L.CITY "도시 명", C.COUNTRY_NAME "국가 명"
FROM LOCATIONS L JOIN COUNTRIES C
ON L.COUNTRY_ID = C.COUNTRY_ID; 

--FIRST_NAME, LAST_NAME, JOB_ID, JOB_TITLE을 조회(EMPLOYEES와 JOBS)
SELECT * FROM JOBS;

SELECT E.FIRST_NAME, E.LAST_NAME, E.JOB_ID, J.JOB_TITLE
FROM EMPLOYEES E JOIN JOBS J
ON E.JOB_ID = J.JOB_ID;
