SELECT * FROM flower;
SELECT flower_name, flower_color, flower_price FROM flower;
-- * 를 쓰게 되면 컬럼의 이름부터 탐색을 해야하기 때문에
-- 컬럼의 이름을 직접 써주는 것이 속도가 훨씬 빠르다. -> 데이터의 용량이 클 경우

INSERT INTO FLOWER
(FLOWER_NAME, FLOWER_COLOR, FLOWER_PRICE)
VALUES('장미', 'RED', 3000);

INSERT INTO FLOWER
(FLOWER_NAME, FLOWER_COLOR, FLOWER_PRICE)
VALUES('해바라기', 'YELLOW', 5000);

INSERT INTO FLOWER
(FLOWER_NAME, FLOWER_COLOR, FLOWER_PRICE)
VALUES('할미꽃', 'WHITE', 9000);

SELECT * FROM POT;

INSERT INTO POT
(POT_NUM, POT_COLOR, POT_PATTERN, FLOWER_NAME)
VALUES('20230222001', 'WHITE', '물레방아', '장미');

INSERT INTO POT
(POT_NUM, POT_COLOR, POT_PATTERN, FLOWER_NAME)
VALUES('20230222002', 'WHITE', '물레방아', '해바라기');

INSERT INTO POT
(POT_NUM, POT_COLOR, POT_PATTERN, FLOWER_NAME)
VALUES('20230222003', 'BLACK', '타원형', '할미꽃');

INSERT INTO POT
(POT_NUM, POT_COLOR, POT_PATTERN, FLOWER_NAME)
VALUES('20230222004', 'RED', '사각형', '할미꽃');

-- PK는 중복 불가능, FK는 중복이 가능하다.

-- 삭제
--DELETE FROM POT; -- 내용 전체 삭제
DELETE FROM POT WHERE FLOWER_NAME = '장미';

DELETE FROM FLOWER WHERE FLOWER_NAME = '장미';
-- DELETE FROM FLOWER WHERE FLOWER_NAME = '해바라기';
-- FK(자식)로 항목을 사용할 경우 PK(부모)를 지울 수 없다.
-- 부모와 자식 중 자식 테이블에서 참조하는 값들을 먼저 삭제해야 부모테이블에서 삭제 가능

-- PARTNER 테이블과 PET 테이블에 데이터 넣어보기
SELECT * FROM PET;
SELECT * FROM PARTNER;

INSERT INTO PARTNER
(PARTNER_ID, PARTNER_NAME, PARTNER_AGE, PARTNER_ADDRESS)
VALUES('20230120001', '홍길동', 25, '서울시 강남구');

INSERT INTO PARTNER
(PARTNER_ID, PARTNER_NAME, PARTNER_AGE, PARTNER_ADDRESS)
VALUES('20230120002', '김길동', 30, '인천시 부평구');

INSERT INTO PET
(PET_PIN, PET_NAME, PET_AGE, PARTNER_ID, GENDER)
VALUES('9202001', '뽀삐', 4, '20230120001', 'M');

INSERT INTO PET
(PET_PIN, PET_NAME, PET_AGE, PARTNER_ID)
VALUES('9202002', '노루', 4, '20230120002');

INSERT INTO PET VALUES('9301001', '바둑이', 3, '20230120002', 'W');

-- 성별이 남자인 모든 애완동물의 정보를 조회해보세요.
SELECT * FROM PET WHERE GENDER = 'M';

-- 이름이 바둑이인 애완동물의 정보를 삭제해보세요.
DELETE FROM PET WHERE PET_NAME = '바둑이';

-- ID가 20230120002인 사람의 이름을 이순신으로 변경하기
UPDATE PARTNER
SET PARTNER_NAME = '이순신'
WHERE PARTNER_ID = '20230120002';

SELECT * FROM PARTNER;

-- 조회된 데이터를 파일형식(CSV, HTML, SQL)으로 저장
-- 선택 후 우클릭으로 결과내보내기
SELECT * FROM JOBS;

SELECT * FROM PLAYER;

-- PLAYER 테이블에서 TEAM_ID가 'K01'인 선수들의 정보를 조회하세요.
SELECT * FROM PLAYER WHERE TEAM_ID = 'K01';

-- PLAYER 테이블에서 TEAM_ID가 'K01'이 아닌 선수들의 정보를 조회하세요
SELECT * FROM PLAYER WHERE TEAM_ID != 'K01';

-- PLAYER 테이블에서 몸무게가 70이상이고 80이하인 선수만 검색
SELECT * FROM PLAYER WHERE WEIGHT >= 70 AND WEIGHT <= 80;
SELECT * FROM PLAYER WHERE WEIGHT BETWEEN 70 AND 80; -- BETWEEN은 이상과 이하에만 사용 가능, 초과와 미만은 사용 불가

-- PLAYER 테이블에서 TEAM_ID가 'K03'이고 키가 180인 선수만 조회
SELECT * FROM PLAYER WHERE TEAM_ID = 'K03' AND HEIGHT = 180;

-- PLAYER 테이블에서 TEAM_ID가 'K02'이거나 'K07'이고 포지션은 'MF'인 선수 조회
-- OR과 AND가 동시에 사용되면 AND가 먼저 연산된다. OR을 먼저 연산하려면 ()를 사용한다.
SELECT * FROM PLAYER 
WHERE (TEAM_ID = 'K02' OR TEAM_ID = 'K07') AND "POSITION" = 'MF';
SELECT * FROM PLAYER 
WHERE TEAM_ID IN ('K02', 'K07') AND "POSITION" = 'MF';

-- 사원 테이블에서 이름, 직종, 급여를 조회하세요.
SELECT * FROM EMPLOYEES;
SELECT FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES;

-- SELECT 안에서 간단한 연산도 가능하다.
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, COMMISSION_PCT, SALARY * COMMISSION_PCT FROM EMPLOYEES;

-- 사원 테이블에서 급여가 10000 이상인 사원들의 정보를 사번, 이름, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES 
WHERE SALARY >= 10000;

-- 사원 테이블에서 이름이 MICHAEL인 사원의 사번, 이름을 조회
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES 
WHERE FIRST_NAME = 'Michael';

-- 사원 테이블에서 직종이 IT_PROG인 사원들의 정보를 사번, 이름, 직종, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

-- 사원 테이블에서 입사일이 05년 9월 21일 이후에 입사한 사원들의 정보를 사번, 이름, 입사일 순으로 조회
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
WHERE HIRE_DATE >= TO_DATE('2005-09-21', 'YYYY-MM-DD');

-- 사원 테이블에서 급여가 2200, 3200, 5000, 6800을 받는 사원들의 정보를
-- 사번, 이름, 직종, 급여 순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE SALARY = 2200 OR SALARY = 3200 OR SALARY = 5000 OR SALARY = 6800;

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY FROM EMPLOYEES
WHERE SALARY IN (2200, 3200, 5000, 6800);